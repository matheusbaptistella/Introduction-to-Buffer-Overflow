# How does a C program executes? 
Reversing programs involves comprehending different sorts of code, such as a `zip` file or maybe just an `ELF` executable. In order to be prepared to face peculiar appearences of a simple applications, we must comprehend how a program is executed in a machine, and, to do so, we'll get started by analysing a **C program**: from stages of converting the source code, to linking libraires, for example.

## A text file
Usually, the steps for creating your source code are always the same: you open your preferred text editor/IDE, write some code and then save it somewhere on your machine.
Have in mind that this is not yet our program: we simply created a text file, which is stored in secondary memory (HDD/SSD). To make it a "program" (executable), we need to transform a texte file into an [ELF 64bits object](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format).

Consider the following C code:

```C
/*
  NOTE: You can find it at the "examples" folders as "example1.c"
*/

#include <stdio.h>
#include <stdlib.h>

int global_var;
int init_global_var = 5;

void function(){
	int stack_var;
	int init_stack_var = 30;

	char buff_var[32];
	
	printf("function's stack_var is at address %p\n", &stack_var);
	printf("function's init_stack_var is at address %p\n", &init_stack_var);
	printf("function's buff_var is at address %p\n", buff_var);
}

int main(int argc, char **argv){
	int stack_var;
	int init_stack_var = 10;

	static int static_var;
	static int init_static_var = 20;
	
	char buff_var[32];

	int *heap_var_ptr;
	heap_var_ptr = (int *) malloc(32);

	printf("the first command line argument is at address %p\n\n", &argv[0]);

	printf("program's init_global_var is at address %p\n", &init_global_var);
	printf("main's init_static var is at address %p\n\n", &init_static_var);

	printf("program's global_var is at address %p\n", &global_var);
	printf("main's static_var_ptr is at address %p\n\n", &static_var);

	printf("main's heap_var is at address %p\n\n", heap_var_ptr);

	printf("main's stack_var is at address %p\n", &stack_var);
	printf("main's init_stack_var is at address %p\n", &init_stack_var);
	printf("main's buff_var is at address %p\n\n", &buff_var);

	function();
	
	return 0;
}
```

On terminal, we can see what kind of file it is by using the `file` command:

```
file ./example1.c
./example1.c: C source, ASCII text
```

As mentioned previously, `example1.c` is a text file, more precisely an [ASCII](https://en.wikipedia.org/wiki/ASCII) text, meaning it contains only ASCII characters (check [this](https://www.asciitable.com/) table). Basically, all we've to do now is to **compile** this text into an object, but the process of compilation is very complex, so we'll get an overview of it and highlight the important stages.

## Compilation
The process of compilation can be divided into 4 stages:

1. Preprocessing.
2. Compilation.
3. Assembly.
4. Linking.

Initially, the preprocessing stage will interpret preprocessing directives in your code (lines starting with `#`), which will expand [header files](https://gcc.gnu.org/onlinedocs/cpp/Header-Files.html) and create macros, to reduce repetition of code, for example, and also remove comments. Following, compilation will translate the code generated in the previous stage to assembly instructions specific to the target processor. Next, an assembler will convert the assembly instructions generated by the compilation stage, into object code (what your computer actually understadands!). Finally, a linker will be used to link function references in our code to their respective libraries: for instance, a call to `printf()` would require its address on `libc` to be loaded into our code, so that, instead of copying all printf's code, we go to it's address and execute what's in there (see [dynamic linking](https://medium.com/@bdov_/https-medium-com-bdov-c-dynamic-libraries-what-why-and-how-66cf777019a7)).

Practically, this can be achieved with the use of GCC ([here](https://en.wikipedia.org/wiki/GNU_Compiler_Collection) for more details), which is the compiler we'll be using throughout this material. On terminal, we can use the `GCC` command:

```
gcc ./example1.c -o example1
```

This will take the current directory `example1.c` file as input, and compile it with the flag `-o`, which will generate `example1` as the output executable. Also, with the `file` command we can confirm that it's indeed an executable:

```
file ./example1
example1: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=44207b0f09a72d6971273de348ebb0c95d17cd04, for GNU/Linux 3.2.0, not stripped
```

Notice that we can only execute `example1` because the output file has permissions to be executed. We can verify it using the `ls` command assing the `-l` flag:

```
ls -l
-rwxrwxr-x [...] example1
-rw-rw-r-- [...] example1.c
```

The output show us that `example1` has permissions for the `user`, `group` and `others` to execute it ([here](https://www.pair.com/support/kb/file-permissions/) for more details), whereas our text file `example1.c` doesn't. Even if we used the `chmod` command to give executable permissions to the latter, the machine would try to execute the text as instructions, which would certainly return a syntax error.

## Memory layout
Until now, we started with a text file containing the code that we wanted to execute, then we compiled it, transforming its C instructions into assembly instructions and linking library adresses, which generated an ELF64 executable file. However, currently both files are stored in secondary memory and, in order to execute a file, it must be loaded into main memory (RAM).

Furthermore, when information is loaded into RAM our memory gets "divided" and labeled into sections, due to the fact that different regions of our program have distinct access permissions. For example, imagine that you created an `int` and an `int static` variables: certainly, if you set a variable to static, you don't want its value to change. So, to avoid security issues where static variables are changeable you may put them into a region of memory that is readable but not writable, therefore ensuring that the variables in there won't change.

The image below represents the divisions and labels, that is the layout, of the virtual memory of an executing C program in Linux (an ELF):

![](./pictures/elf_memory_layout.png "Memory layout of an ELF file loaded into main memory.)
