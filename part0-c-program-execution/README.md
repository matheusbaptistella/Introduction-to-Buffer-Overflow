# How does a C program executes? 
Reversing programs involves comprehending different sorts of code, such as a `zip` file or maybe just an `ELF` executable. In order to be prepared to face peculiar appearences of a simple applications, we must comprehend how a program is executed in a machine, and, to do so, we'll get started by analysing a **C program**: from stages of converting the source code, to linking libraires, for example.

## A text file
Usually, the steps for creating your source code are always the same: you open your preferred text editor/IDE, write some code and then save it somewhere on your machine.
Have in mind that this is not yet our program: we simply created a text file, which is stored in secondary memory (HDD/SSD). To make it a "program" (executable), we need to transform a texte file into an [ELF 64bits object](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format).

Consider the following C code:

```C
/*
  NOTE: You can find it at the "examples" folders as "example1.c"
*/

#include <stdio.h>
#include <stdlib.h>

int global_var;
int init_global_var = 5;

void function(){
	int stack_var;
	int init_stack_var = 30;

	char buff_var[32];
	
	printf("function's stack_var is at address %p\n", &stack_var);
	printf("function's init_stack_var is at address %p\n", &init_stack_var);
	printf("function's buff_var is at address %p\n", buff_var);
}

int main(int argc, char **argv){
	int stack_var;
	int init_stack_var = 10;

	static int static_var;
	static int init_static_var = 20;
	
	char buff_var[32];

	int *heap_var_ptr;
	heap_var_ptr = (int *) malloc(32);

	printf("the first command line argument is at address %p\n\n", &argv[0]);

	printf("program's init_global_var is at address %p\n", &init_global_var);
	printf("main's init_static var is at address %p\n\n", &init_static_var);

	printf("program's global_var is at address %p\n", &global_var);
	printf("main's static_var_ptr is at address %p\n\n", &static_var);

	printf("main's heap_var is at address %p\n\n", heap_var_ptr);

	printf("main's stack_var is at address %p\n", &stack_var);
	printf("main's init_stack_var is at address %p\n", &init_stack_var);
	printf("main's buff_var is at address %p\n\n", &buff_var);

	function();
	
	return 0;
}
```

On terminal, we can see what kind of file it is by using the `file` command:

```
$ file ./example1.c
./example1.c: C source, ASCII text
```

As mentioned previously, `example1.c` is a text file, more precisely an [ASCII](https://en.wikipedia.org/wiki/ASCII) text, meaning it contains only ASCII characters (check [this](https://www.asciitable.com/) table). Basically, all we've to do now is to **compile** this text into an object, but the process of compilation is very complex, so we'll get an overview of it and highlight the important stages.

## Compilation
The process of compilation can be divided into 4 stages:

1. Preprocessing.
2. Compilation.
3. Assembly.
4. Linking.

Initially, the preprocessing stage will interpret preprocessing directives in your code (lines starting with `#`), which will expand [header files](https://gcc.gnu.org/onlinedocs/cpp/Header-Files.html) and create macros, to reduce repetition of code, for example, and also remove comments. Following, compilation will translate the code generated in the previous stage to assembly instructions specific to the target processor. Next, an assembler will convert the assembly instructions generated by the compilation stage, into object code (what your computer actually understadands!). Finally, a linker will be used to link function references in our code to their respective libraries: for instance, a call to `printf()` would require its address on `libc` to be loaded into our code, so that, instead of copying all printf's code, we go to it's address and execute what's in there (see [dynamic linking](https://medium.com/@bdov_/https-medium-com-bdov-c-dynamic-libraries-what-why-and-how-66cf777019a7)).

Practically, this can be achieved with the use of GCC ([here](https://en.wikipedia.org/wiki/GNU_Compiler_Collection) for more details), which is the compiler we'll be using throughout this material. On terminal, we can use the `GCC` command:

```
$ gcc ./example1.c -o example1
```

This will take the current directory `example1.c` file as input, and compile it with the flag `-o`, which will generate `example1` as the output executable. Also, with the `file` command we can confirm that it's indeed an executable:

```
$ file ./example1
example1: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=44207b0f09a72d6971273de348ebb0c95d17cd04, for GNU/Linux 3.2.0, not stripped
```

Notice that we can only execute `example1` because the output file has permissions to be executed. We can verify it using the `ls` command alongside the `-l` flag:

```
$ ls -l
-rwxrwxr-x [...] example1
-rw-rw-r-- [...] example1.c
```

The output show us that `example1` has permissions for the `user`, `group` and `others` to execute it ([here](https://www.pair.com/support/kb/file-permissions/) for more details), whereas our text file `example1.c` doesn't. Even if we used the `chmod` command to give executable permissions to the latter, the machine would try to execute the text as instructions, which would certainly return a syntax error.

Now, we've transformed the lines of code that we wrote (`example1.c`) into assembly (`example1` ELF file). Yet, the machine still can't comprehend these instructions, what will actually go into our processor are the opcodes that translate into their respective assembly instructions. Lets verify it using the `objdump`command from the terminal:

```
$ objdump -M intel -d example1
[...]
000000000000120a <main>:
    120a:       f3 0f 1e fa             endbr64
    120e:       55                      push   rbp
    120f:       48 89 e5                mov    rbp,rsp
    1212:       48 83 ec 50             sub    rsp,0x50
    1216:       89 7d bc                mov    DWORD PTR [rbp-0x44],edi
    1219:       48 89 75 b0             mov    QWORD PTR [rbp-0x50],rsi
    121d:       64 48 8b 04 25 28 00    mov    rax,QWORD PTR fs:0x28
    1224:       00 00
    1226:       48 89 45 f8             mov    QWORD PTR [rbp-0x8],rax
    122a:       31 c0                   xor    eax,eax
    122c:       c7 45 c4 0a 00 00 00    mov    DWORD PTR [rbp-0x3c],0xa
    1233:       bf 20 00 00 00          mov    edi,0x20
    1238:       e8 53 fe ff ff          call   1090 <malloc@plt>
[...]
```

The above snippet from function `main` of `example1` shows what is actually interpreted by the machine: our text code got tranformed into assembly instructions, which are then translated into opcodes. Opcodes are bytes that the processor interprets as the assembly instruction they represent ([here](http://ref.x86asm.net/coder64.html#x0A) you can find them all for our x86_64 architecture). Lets look closely to line `1212`:

```
1212:       48 83 ec 50             sub    rsp,0x50
```

Basically, what assembly tells us is that when our program executes this line of our program, it should `sub`stract `0x50` bytes from `rsp` (the stack pointer). But what is sent to the processor are the opcodes (in hexadecimal): `\x48 \x83 \xec \x50`.

## Memory layout
Until now, we started with a text file containing the code that we wanted to execute, then we compiled it, transforming its C instructions into assembly instructions and linking library adresses, which generated an ELF64 executable file. However, currently both files are stored in secondary memory and, in order to execute a file, it must be loaded into main memory (RAM).

Furthermore, when information is loaded into RAM our memory gets "divided" and labeled into sections, due to the fact that different regions of our program have distinct access permissions. For example, imagine that you created an `int` and an `int static` variables: certainly, if you set a variable to static, you don't want its value to change. So, to avoid security issues where static variables are changeable you may put them into a region of memory that is readable but not writable, therefore ensuring that the variables in there won't change.

The image below represents the divisions and labels, that is the layout, of the virtual memory of an executing C program in Linux (an ELF):

![alt text](./pictures/elf_memory_layout.png "Memory layout of an ELF file loaded into main memory.")

We'll start covering those sections from lower addresses to higher addresses:

* ELF Header
  * The header of a file is commonly used with the purpose of containing the values of differente aspects of the file (for example, the size of the file, the entry point and so on...). What is useful about headers in general is that those values are always on the same position, that is, the same distance from the beggining of the file. For instance, the flag (value) that tells the program which method to use to decompress a `PKZip` file will always be 8 bytes (offset) from the beginning of the local header ([here](https://users.cs.jmu.edu/buchhofp/forensics/formats/pkzip.html#general) if you got curious). Similarly for an ELF: its header will contain information about that file.
  
* .text
  * 
