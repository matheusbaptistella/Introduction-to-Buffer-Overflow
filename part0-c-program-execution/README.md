# How does a C program executes? 
Reversing programs involves comprehending different sorts of code, such as a `zip` file or maybe just an `ELF` executable. In order to be prepared to face peculiar appearences of a simple applications, we must comprehend how a program is executed in a machine, and, to do so, we'll get started by analysing a **C program**: from stages of converting the source code, to linking libraires, for example.

## A text file
Usually, the steps for creating your source code are always the same: you open your preferred text editor/IDE, write some code and then save it somewhere on your machine.
Have in mind that this is not yet our program: we simply created a text file, which is stored in secondary memory (HDD/SSD). To make it a "program" (executable), we need to transform a texte file into an [ELF 64bit object](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format).

Consider the following C code:

```C
/*
  NOTE: You can find it at the "examples" folders as "example1.c"
*/

#include <stdio.h>
#include <stdlib.h>

int global_var;
int init_global_var = 5;

void function(){
	int stack_var;
	int init_stack_var = 30;

	char buff_var[32];
	
	printf("function's stack_var is at address %p\n", &stack_var);
	printf("function's init_stack_var is at address %p\n", &init_stack_var);
	printf("function's buff_var is at address %p\n", buff_var);
}

int main(int argc, char **argv){
	int stack_var;
	int init_stack_var = 10;

	static int static_var;
	static int init_static_var = 20;
	
	char buff_var[32];

	int *heap_var_ptr;
	heap_var_ptr = (int *) malloc(32);

	printf("the first command line argument is at address %p\n\n", &argv[0]);

	printf("program's init_global_var is at address %p\n", &init_global_var);
	printf("main's init_static var is at address %p\n\n", &init_static_var);

	printf("program's global_var is at address %p\n", &global_var);
	printf("main's static_var_ptr is at address %p\n\n", &static_var);

	printf("main's heap_var is at address %p\n\n", heap_var_ptr);

	printf("main's stack_var is at address %p\n", &stack_var);
	printf("main's init_stack_var is at address %p\n", &init_stack_var);
	printf("main's buff_var is at address %p\n\n", &buff_var);

	function();
	
	return 0;
}
```

On terminal, we can see what kind of file it is by using the `file` command:

```
file ./example1.c
./example1.c: C source, ASCII text
```

As mentioned previously, `example1.c` is a text file, more precisely an [ASCII](https://en.wikipedia.org/wiki/ASCII) text, meaning it contains only ASCII characters (check [this](https://www.asciitable.com/) table). Basically, all we've to do now is to **compile** this text into an object, but the process of compilation is very complex, so we'll get an overview of it and highlight the important stages.

## Compilation
The process of compilation can be divided into 4 stages:

1. Preprocessing.
2. Compilation.
3. Assembly.
4. Linking.

Initially, the preprocessing stage will interpret preprocessing directives in your code (lines starting with `#`), which will expand [header files](https://gcc.gnu.org/onlinedocs/cpp/Header-Files.html) and create macros, to reduce repetition of code, for example, and also remove comments. Following, compilation will translate the code generated in the previous stage to assembly instructions specific to the target processor. Next, an assembler will convert the assembly instructions generated by the compilation stage, into object code (what your computer actually understadands!). Finally, a linker will be used to link function references in our code to their respective libraries: for instance, a call to `printf()` would require its address on `libc` to be loaded into our code, so that, instead of copying all printf's code, we go to it's address and execute what's in there (see [dynamic linking](https://medium.com/@bdov_/https-medium-com-bdov-c-dynamic-libraries-what-why-and-how-66cf777019a7)).

## 

